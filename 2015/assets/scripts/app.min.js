/* ========================================================================
 * Bootstrap: affix.js v3.3.5
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.5'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);
!(function($) {
  'use strict';

  $('.top-navigation').on('click', '.shared-btn', function(e) {
    e.preventDefault();

    if ($(this).data('target') === 'fb') {
      shareFb();
    } else if ($(this).data('target') === 'tw') {
      shareTw();
    }

  });

  $('#d-day').ready(function() {
    var now = new Date();
    var then = new Date("november 12,2015");
    var gap = then.getTime() - now.getTime();
    gap = Math.floor(gap / (1000 * 60 * 60 * 24));
    $('#d-day').text(' (d-' + gap + ')');
  });

  $('.top-navigation').on('click', 'a', function() {
    if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
      var target = $(this.hash);
      target = target.length ? target : $('[name=' + this.hash.slice(1) +']');

      if (target.length) {
        $('#top-naviation').removeClass('active');

        $('html,body').animate({
          scrollTop: target.offset().top - 70
        }, 500);
        return false;
      }
    }
  });

  $('.speakers').on('click', '[data-toggle="speakers"]', function(e) {
    e.preventDefault();

    $('body').removeClass('modal-open');

    var target = $(this);
    var name = target.data('name');

    if(target.data('sns')) {
      name = $('<a/>', {
        target: '_blink',
        href : target.data('sns'),
        text: target.data('name')
      });
    }

    $('#profileModalImg').attr('src', target.data('img'));
    $('#profileModalName').html(name);
    $('#profileModalCompany').text(target.data('company'));
    $('#profileModalInfo').html(target.data('info'));

    $('body').addClass('modal-open');

  });

  $('body').on('click', '.profile-modal-container', function(e) {
    if($(e.target).parents('.profile-modal-container').length === 0) {
      $('body').removeClass('modal-open');
    }
  });

  $('.profile-modal-close-button button').on('click' ,function() {
    $('body').removeClass('modal-open');
  });

  $('.navbar-toggle').on('click', function() {
    $('#top-naviation').addClass('active');
  });

  $('.nav-close-button button').on('click', function() {
    $('#top-naviation').removeClass('active');
  });

})(window.jQuery);

!(function($) {
  'use strict';

  var Slideshow = function(ele, options) {
      this.options        = options;
      this.$ele           = $(ele);
      this.$slides        = this.$ele.children('li');
      this.timmer         = null;
      this.currentIndex   = 0; // Todo random start
      if(this.options.shuffle) {
        this.$slides = this.shuffle(this.$slides);
      }
  };

  Slideshow.defulats = {
    interval: 2500,
    duration: 1500,
    shuffle: true 
  };

  Slideshow.prototype.play = function() {
    var self = this;
    self.next();
  };

  Slideshow.prototype.pause = function() {
    //Todo
  };

  Slideshow.prototype.shuffle = function(array) {
    for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];

        array[i] = array[j];
        array[j] = temp;
    }
    return array;
  };

  Slideshow.prototype.next = function() {
    var self = this;
    var nextIndex = (self.$slides.length <= self.currentIndex + 1) ? 0 : self.currentIndex + 1;
    
    var nextSlide = $(self.$slides[nextIndex]);
    var currentSlide = $(self.$slides[self.currentIndex]);
    
    nextSlide
      .css('display', 'block')
      .fadeTo(self.options.duration, 1, function() {

        $(this).animate({
          transform: 'scale(2) rotate(90deg)'
        }, self.options.interval);

        self.currentIndex = nextIndex;

        self.timmer = setTimeout(function() {
          self.next();
        }, self.options.interval);
      });

    currentSlide
      .fadeTo(self.options.duration, 0, function() {
          $(self).css('display', 'none');
      });
  };

  function Plugin(option) {
    return this.each(function() {
      var $this   = $(this),
          data    = $this.data('slideshow'),
          options = $.extend({}, Slideshow.defulats, $this.data(), typeof option == 'object' && option);

      if (!data) $this.data('slideshow', (data = new Slideshow(this, options)));    
      if(typeof options === 'string') data[options]();
      else data.play();
    });
  }

  var old = $.fn.slideshow;

  $.fn.slideshow              = Plugin;
  $.fn.slideshow.Constructor  = Slideshow;

  $.fn.slideshow.noConflict   = function () {
    $.fn.slideshow = old
    return this
  }

  $('[data-toggle="slideshow"]').each(function() {
    var $this = $(this);
    Plugin.call($this, $this.data());
  });

})(window.jQuery);

!(function($) {
  'use strict';

  var Sticky = function(ele, options) {
    this.options        = options;
    this.$ele           = $(ele);
    this.offsetTop      = 0;
    this.prevScrollTop  = 0;
  };

  Sticky.defulats = {

  };

  Sticky.prototype.init = function() {
    this.$ele.on('scroll', $.proxy(this.onContentScroll, this));
  };

  Sticky.prototype.onContentScroll = function(e) {
    var scrollTop = this.$ele.scrollTop();

    this.prevScrollTop = this.prevScrollTop || 0;
    this.offsetTop = this.offsetTop || 0;

    if(scrollTop > this.options.offset) {
      $(this.options.target).addClass('affix');
    } else {
      $(this.options.target).removeClass('affix');
    }

    /* animation-element */
    var $window = $(window);
    // $window.on('scroll resize', check_if_in_view);
    $window.trigger('scroll');

    var window_height = $window.height();
    var window_top_position = $window.scrollTop();
    var window_bottom_position = (window_top_position + window_height);

    var $animation_elements = $('.animation-element');

    $.each($animation_elements, function() {
      var $element = $(this);
      var element_height = $element.outerHeight();
      var element_top_position = $element.offset().top;
      var element_bottom_position = (element_top_position + element_height);

      //check to see if this current container is within viewport
      if ((element_bottom_position >= window_top_position) &&
        (element_top_position <= window_bottom_position)) {
        $element.addClass('in-view');
      } else {
        // $element.removeClass('in-view');
      }
    });

  };

  function Plugin(option) {
    return this.each(function() {
      var $this   = $(this),
          data    = $this.data('sticky'),
          options = $.extend({}, Sticky.defulats, $this.data(), typeof option == 'object' && option);

      if (!data) $this.data('sticky', (data = new Sticky(this, options)));
      if(typeof options === 'string') data[options]();
      else data.init();
    });
  }

  var old = $.fn.sticky;

  $.fn.sticky              = Plugin;
  $.fn.sticky.Constructor  = Sticky;

  $.fn.sticky.noConflict   = function () {
    $.fn.sticky = old
    return this
  }

  $('[data-toggle="sticky"]').each(function() {
    var $this = $(this);
    Plugin.call($this, $this.data());
  });

})(window.jQuery);

!(function($) {
  'use strict';

  var Typingtext = function(ele, options) {
      this.options        = options;
      this.$ele           = $(ele);
      this.$items         = this.$ele.children('span');
      this.interval       = null;
  };

  Typingtext.defulats = {
    interval: 500,
  };

  Typingtext.prototype.play = function() {
    var self = this;
    var index = 0;
    self.interval =  setInterval(function() {
      if(index >= self.$items.length) {
        clearInterval(self.interval);
      }

      $(self.$items[index]).css({
        display: 'inline-block',
        opacity: 1
      });

      index++;
    }, 75);
    
  };

  function Plugin(option) {
    return this.each(function() {
      var $this   = $(this),
          data    = $this.data('typingtext'),
          options = $.extend({}, Typingtext.defulats, $this.data(), typeof option == 'object' && option);

      if (!data) $this.data('typingtext', (data = new Typingtext(this, options)));    
      if(typeof options === 'string') data[options]();
      else data.play();
    });
  }

  var old = $.fn.typingtext;

  $.fn.typingtext              = Plugin;
  $.fn.typingtext.Constructor  = Typingtext;

  $.fn.typingtext.noConflict   = function () {
    $.fn.typingtext = old
    return this
  }

  $('[data-toggle="typingtext"]').each(function() {
    var $this = $(this);
    Plugin.call($this, $this.data());
  });

})(window.jQuery);

!(function($) {
  'use strict';

  var defaultMsg = '사용가능한 명령어를 확인하려면 help()를 실행하세요.' +
                   '\n그 외 JavaScript 코드를 사용할 수 있습니다.' +
                   '\n\n';

  var jqconsole = $('#console').jqconsole(defaultMsg, '> '),
      startPrompt;
  var runCli = function() {
    jqconsole.Reset();
    startPrompt = function() {
      jqconsole.Prompt(true, function (input) {
        input = $.trim(input);

        if (input === '') { return startPrompt(); }
        try {
          var result = window.eval(input);
          jqconsole.Write(result + '\n', 'jqconsole-output');
        } catch(e) {
          jqconsole.Write(e.message + '\n', 'jqconsole-output');
        }
        startPrompt();
      });
    };
    startPrompt();
    jqconsole.Focus();
  }

  var $webcli = $('#webcli'),
      $cliHandle = $('#cli-handle');

  $cliHandle.on('click', function(e) {
    var $this = $(this);
    $webcli.toggleClass('active');
    $this.children('.icon').toggleClass('icono-terminal').toggleClass('icono-cross');
    if ($webcli.hasClass('active')) {
      runCli();
    }
  });

  // commands
  window.help = function() {
    return '콘솔에서는 ' +
           'shareFb(), shareTw(), ' +
           'clear(), exit()' +
           '를 사용할 수 있습니다.';
  };
  window.clear = function() {
    setTimeout(function() {
      jqconsole.Reset();
      startPrompt();
    }, 0);
  };
  window.exit = function() {
    $webcli.toggleClass('active');
    $cliHandle.children('.icon').toggleClass('icono-terminal').toggleClass('icono-cross');
    if ($webcli.hasClass('active')) {
      runCli();
    }
  };
  window.shareFb = function() {
    var w = 400, h = 300,
        l = (window.screen.width / 2) - ((400 / 2) + 10),
        t = (window.screen.height / 2) - ((300 / 2) + 50);
    var qs = "status=no,height=" + h + ",width=" + w + ",resizable=yes,left=" + l +
      ",top=" + t + ",screenX=" + l + ",screenY=" + t +
      ",toolbar=no,menubar=no,scrollbars=no,location=no,directories=no";

    var popupUrl = 'https://www.facebook.com/dialog/share?app_id=808686202580087' +
                   '&href=' + encodeURIComponent('http://playnode.io') +
                   '&display=popup&redirect_uri=' + encodeURIComponent('http://playnode.io/fb-close.html');
    window.open(popupUrl, 'play.node 2015', qs);
  };
  window.shareTw = function() {
    var w = 400, h = 300,
        l = (window.screen.width / 2) - ((400 / 2) + 10),
        t = (window.screen.height / 2) - ((300 / 2) + 50);
    var qs = "status=no,height=" + h + ",width=" + w + ",resizable=yes,left=" + l +
      ",top=" + t + ",screenX=" + l + ",screenY=" + t +
      ",toolbar=no,menubar=no,scrollbars=no,location=no,directories=no";

    var popupUrl = 'https://twitter.com/intent/tweet?url=' + encodeURIComponent('http://playnode.io') +
                   '&text=' + encodeURIComponent('node.js 컨퍼런스 playnode가 3년 만에 다시 여러분을 찾아 갑니다.') + '&via=playnodeconf';
    window.open(popupUrl, 'play.node 2015', qs);
  };
})(window.jQuery);
